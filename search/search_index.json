{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"B865: 8-bit Breadboard Computer The B865 is a homebrew 8-bit computer built on a breadboard, featuring a custom CPU, 64KB of addressable memory, and 7 8-bit general-purpose registers (2 can be used for indexing), 8-bit stack pointer, 16-bit program counter. Specifications Data Bus : 8-bit Address Bus : 16-bit Registers : 8-bit: A, SP, X, Y, R0, R1, R2, R3 16-bit: PC Status register(S): (3-bit: Carry, Zero, Negative) Memory : 64KB (32k ROM + 32k RAM) Instruction Set Full Instruction Set Documentation Memory Map Address Range Usage 0x0000-0x7FFF RAM 0x8000-0xFFFF ROM Pheripherials registers in RAM: Address Range Pheripherial 0x0200-0x0207 GPIO How It Works The CPU is built using 74-series logic, with a microcoded control unit stored in EEPROM. It executes instructions from ROM, with RAM mapped to lower memory for stack and variable storage.","title":"Home"},{"location":"#b865-8-bit-breadboard-computer","text":"The B865 is a homebrew 8-bit computer built on a breadboard, featuring a custom CPU, 64KB of addressable memory, and 7 8-bit general-purpose registers (2 can be used for indexing), 8-bit stack pointer, 16-bit program counter.","title":"B865: 8-bit Breadboard Computer"},{"location":"#specifications","text":"Data Bus : 8-bit Address Bus : 16-bit Registers : 8-bit: A, SP, X, Y, R0, R1, R2, R3 16-bit: PC Status register(S): (3-bit: Carry, Zero, Negative) Memory : 64KB (32k ROM + 32k RAM)","title":"Specifications"},{"location":"#instruction-set","text":"Full Instruction Set Documentation","title":"Instruction Set"},{"location":"#memory-map","text":"Address Range Usage 0x0000-0x7FFF RAM 0x8000-0xFFFF ROM Pheripherials registers in RAM: Address Range Pheripherial 0x0200-0x0207 GPIO","title":"Memory Map"},{"location":"#how-it-works","text":"The CPU is built using 74-series logic, with a microcoded control unit stored in EEPROM. It executes instructions from ROM, with RAM mapped to lower memory for stack and variable storage.","title":"How It Works"},{"location":"addressing-modes/","text":"Addressing modes Code Addressing Mode 0 abs 1 abs+X 2 abs+Y 3 zp 4 zp+X 5 zp+Y 6 immediate 7 (zp+X) 8 (zp+Y) 9 (zp)+X 10 (zp)+Y 11 (zp) 12 illegal 13 sp+i 14 sp+X 15 sp+Y Absolute 2 bytes The absolute addressing mode specifies a full 16-bit address in the instruction, allowing access to any memory location. The operand is the address itself (LE). Absolute, X indexed 2 bytes Adds the value of the X register to a 16-bit base address specified in the instruction. Useful for accessing arrays or tables. Absolute, Y indexed 2 bytes Adds the value of the Y register to a 16-bit base address specified in the instruction. Zeropage 1 byte Uses an 8-bit address, allowing access to the first 256 bytes of memory (zero page). Instructions are shorter and faster. Zeropage, X indexed 1 byte Adds the value of the X register to an 8-bit zero page address. Enables efficient indexed access within the zero page. Zeropage, Y indexed 1 byte Adds the value of the Y register to an 8-bit zero page address. Immediate 1 byte The operand is a constant value included directly in the instruction, not a memory address. Indirect (Zeropage, X indexed) 1 byte Adds X to a zero page address, then uses the resulting address to fetch a 16-bit pointer from zero page. The pointer is then used as the effective address. Indirect (Zeropage, Y indexed) 1 byte Fetches a 16-bit pointer from a zero page address, then adds Y to the pointer to form the effective address. Indirect (Zeropage), X indexed 1 byte Uses a zero page address, adds X to it, and then uses the resulting address to fetch a 16-bit pointer from zero page. The pointer is the effective address. Indirect (Zeropage), Y indexed 1 byte Fetches a 16-bit pointer from a zero page address, then adds Y to the pointer to form the effective address. Indirect (Zeropage) 1 byte Fetches a 16-bit pointer from a zero page address. The pointer is used as the effective address. Stack Pointer, immediate index 0 bytes Adds an immediate value to the stack pointer (SP) to calculate the effective address. Stack Pointer, X indexed 0 bytes Adds the value of the X register to the stack pointer (SP) to form the effective address. Stack Pointer, Y indexed 0 bytes Adds the value of the Y register to the stack pointer (SP) to form the effective address.","title":"Addressing modes"},{"location":"addressing-modes/#addressing-modes","text":"Code Addressing Mode 0 abs 1 abs+X 2 abs+Y 3 zp 4 zp+X 5 zp+Y 6 immediate 7 (zp+X) 8 (zp+Y) 9 (zp)+X 10 (zp)+Y 11 (zp) 12 illegal 13 sp+i 14 sp+X 15 sp+Y","title":"Addressing modes"},{"location":"addressing-modes/#absolute","text":"2 bytes The absolute addressing mode specifies a full 16-bit address in the instruction, allowing access to any memory location. The operand is the address itself (LE).","title":"Absolute"},{"location":"addressing-modes/#absolute-x-indexed","text":"2 bytes Adds the value of the X register to a 16-bit base address specified in the instruction. Useful for accessing arrays or tables.","title":"Absolute, X indexed"},{"location":"addressing-modes/#absolute-y-indexed","text":"2 bytes Adds the value of the Y register to a 16-bit base address specified in the instruction.","title":"Absolute, Y indexed"},{"location":"addressing-modes/#zeropage","text":"1 byte Uses an 8-bit address, allowing access to the first 256 bytes of memory (zero page). Instructions are shorter and faster.","title":"Zeropage"},{"location":"addressing-modes/#zeropage-x-indexed","text":"1 byte Adds the value of the X register to an 8-bit zero page address. Enables efficient indexed access within the zero page.","title":"Zeropage, X indexed"},{"location":"addressing-modes/#zeropage-y-indexed","text":"1 byte Adds the value of the Y register to an 8-bit zero page address.","title":"Zeropage, Y indexed"},{"location":"addressing-modes/#immediate","text":"1 byte The operand is a constant value included directly in the instruction, not a memory address.","title":"Immediate"},{"location":"addressing-modes/#indirect-zeropage-x-indexed","text":"1 byte Uses a zero page address, adds X to it, and then uses the resulting address to fetch a 16-bit pointer from zero page. The pointer is the effective address.","title":"Indirect (Zeropage), X indexed"},{"location":"addressing-modes/#indirect-zeropage-y-indexed","text":"1 byte Fetches a 16-bit pointer from a zero page address, then adds Y to the pointer to form the effective address.","title":"Indirect (Zeropage), Y indexed"},{"location":"addressing-modes/#indirect-zeropage","text":"1 byte Fetches a 16-bit pointer from a zero page address. The pointer is used as the effective address.","title":"Indirect (Zeropage)"},{"location":"addressing-modes/#stack-pointer-immediate-index","text":"0 bytes Adds an immediate value to the stack pointer (SP) to calculate the effective address.","title":"Stack Pointer, immediate index"},{"location":"addressing-modes/#stack-pointer-x-indexed","text":"0 bytes Adds the value of the X register to the stack pointer (SP) to form the effective address.","title":"Stack Pointer, X indexed"},{"location":"addressing-modes/#stack-pointer-y-indexed","text":"0 bytes Adds the value of the Y register to the stack pointer (SP) to form the effective address.","title":"Stack Pointer, Y indexed"},{"location":"instruction-set/","text":"Instruction set Arguments Argument Type Meaning R Register index [A, X, Y, SP, R0, R1, R2, R3] A Addressing mode (0-15) flags Condition Flags Instruction List Mnemonic binary Mnemonic binary RST 00000000 JMP A 00100000 MOV R,R 00000001 reserved 00100001 MOV R,A 00000010 reserved 00100010 MOV A,A 00000011 CLC 00100011 MOV A,R 00000100 reserved 00100100 BRH flags, A 00000101 reserved 00100101 DEX 00000110 STC 00100110 illegal 00000111 illegal 00100111 ADD R, A 00001000 reserved 00101000 SUB R, A 00001001 reserved 00101001 INX 00001010 illegal 00101010 NOP 00001011 HLT 00101011 RSH R 00001100 reserved 00101100 LSH R 00001101 reserved 00101101 ROR R 00001110 reserved 00101110 ROL R 00001111 reserved 00101111 ADD R, R 00010000 reserved 00110000 XNOR R, R 00010001 reserved 00110001 SUB R, R 00010010 reserved 00110010 XOR R, R 00010011 reserved 00110011 OR R, R 00010100 reserved 00110100 NOR R, R 00010101 reserved 00110101 NAND R, R 00010110 reserved 00110110 AND R, R 00010111 reserved 00110111 ADC R, R 00011000 reserved 00111000 PHR R 00011001 reserved 00111001 SBC R, R 00011010 reserved 00111010 PLR R 00011011 reserved 00111011 JSR 00011100 RTS 00111100 CMP R,R 00011101 reserved 00111101 DEC R 00011110 reserved 00111110 INC R 00011111 reserved 00111111 Instruction descriptions Each instruction in the instruction set is documented with the following structure: Instruction Name and Description : The name of the instruction is provided as a heading, followed by a brief description of its purpose and functionality. Arguments : If the instruction takes arguments, they are listed and described. For example, the source and destination registers or memory addresses. C Representation : A snippet of C code is provided to represent the behavior of the instruction. This helps in understanding how the instruction operates at a low level. Memory is a 64kB array (65536 bytes), represents the full memory region (0x0000-0xFFFF). The registers are represented with their name: PC , ACC , X , Y , SP , R0 , R1 , R2 , R3 . The resolveAddress function represents the addresssing mode logic, see Addressing modes , A and B are the ALU's internal registers. Instruction Encoding : The encoding of the instruction in memory is detailed in a table. This includes the byte values and how arguments are encoded into the instruction. Each addressing mode has a differt size in bytes after the instruction, so byte numbers in the instruction descriptions may not be correct. RST (Reset) Resets the processor to its initial state. Before executing this instruction the X register must be set to zero. Size: 1 byte PC = Memory[(X - 1) << 8 + (X - 2)] << 8 + Memory[(X - 1) << 8 + (X - 1)]; X -= 1; So if X is 0 PC will be set to the reset vector at 0xFFFE - 0xFFFF Instruction Byte 0 RST 0x00 MOV R,R (Move Register to Register) Transfers data from one register to another. Size: 2 bytes Arguments: Arg0 = Destinarion register index Arg1 = Source register index Regs[Arg0] = Regs[Arg1]; Instruction Byte 0 Byte 1 MOV R, R 0x01 \\| (Arg0 << 5) Arg1 MOV R,A (Move Register to Address) Moves data from a register to a specified memory address. Size: 2-4 bytes depending on the addressing mode Arguments: Arg0 = Destinarion register index Arg1 = Addressing mode for source byte Regs[Arg0] = *resolveAddress(Arg1); Instruction Byte 0 Byte 1 Byte 2... MOV R, A 0x02 \\| (Arg0 << 5) Arg1 Arguments for addressing mode MOV A,A (Move Address to Address) Transfers data between two memory addresses. Size: 2-6 bytes depending on the addressing modes Arguments: Arg0 = Addressing mode for destination Arg1 = Addressing mode for source byte *resolveAddress(Arg0) = *resolveAddress(Arg1); Instruction Byte 0 Byte 1 Byte 2... MOV R, A 0x03 Arg1 \\| Arg0 << 5 Arguments for addressing modes ( Arg0 first) MOV A,R (Move Address to Register) Moves data from a memory address to a register. Size: 2-4 bytes depending on the addressing mode Arguments: Arg0 = Addressing mode for destination Arg1 = Source register index *resolveAddress(Arg0) = Regs[Arg1]; Instruction Byte 0 Byte 1 Byte 2... MOV R, A 0x04 \\| (Arg1 << 5) Arg0 Arguments for addressing mode BRH flags, A (Branch on Flags) Branches to a specified address based on condition flags. Only 1 flag should be set, if more are set it work as an or operation (if eighter is true it will branch) Size: 3 bytes Arguments: Arg0 = conditon flags, compared with the Status register = Carry | Zero << 1 | Negative << 2 Arg1 = An absolute address, where it will jump to if the conditions are true. (2 bytes) if (S & Arg0) { PC = Arg1; } Instruction Byte 0 Byte 1-2 BRH flags, A 0x05 \\| (Arg0 << 5) Arg1 in LE format DEX (Decrement X) Decrements the X index register by one. Size: 1 byte X -= 1; Instruction Byte 0 DEX 0x06 ADD R, A (Add Register and Address) Adds the value at a memory address to a register. Size: 2-4 bytes depending on the addressing mode Arguments: Arg0 = register index Arg1 = Addressing mode A = Regs[Arg0]; B = *resolveAddress(Arg1); S.carry = (A + B) > 0xFF; S.negative = 0; S.zero = (A + B) == 0; Regs[Arg0] = A + B; Instruction Byte 0 Byte 1 Byte 2... ADD R, A 0x08 \\| (Arg0 << 5) Arg1 Arguments for addressing mode SUB R, A (Subtract Address from Register) Subtracts the value at a memory address from a register. Size: 2-4 bytes depending on the addressing mode Arguments: Arg0 = register index Arg1 = Addressing mode A = Regs[Arg0]; B = *resolveAddress(Arg1); S.carry = (A + ~B + 1) > 0xFF; S.negative = (A - B) < 0; S.zero = (A - B) == 0; Regs[Arg0] = (A + ~B + 1); Instruction Byte 0 Byte 1 Byte 2... SUB R, A 0x09 \\| (Arg0 << 5) Arg1 Arguments for addressing mode INX (Increment X) Increments the X register by one. Size: 1 byte X += 1; Instruction Byte 0 INX 0x0A NOP (No Operation) Performs no operation and advances to the next instruction. Size: 1 byte Instruction Byte 0 NOP 0x0B RSH R (Right Shift Register) Shifts the bits in a register to the right. Size: 1 byte Arguments: Arg0 = register index A = Regs[Arg0]; S.carry = (bool)(A & 0x01); Regs[Arg0] = A >> 1; Instruction Byte 0 RSH R 0x0C \\| Arg0 << 5 LSH R (Left Shift Register) Shifts the bits in a register to the left. Size: 1 byte Arguments: Arg0 = register index A = Regs[Arg0]; S.carry = (bool)(A & 0x80); Regs[Arg0] = A << 1; Instruction Byte 0 LSH R 0x0D \\| Arg0 << 5 ROR R (Rotate Right Register) Rotates the bits in a register to the right, including the carry bit. Size: 1 byte Arguments: Arg0 = register index A = Regs[Arg0]; Regs[Arg0] = A >> 1 | S.carry << 7; S.carry = A & 0x01; Instruction Byte 0 ROR R 0x0E \\| Arg0 << 5 ROL R (Rotate Left Register) Rotates the bits in a register to the left. Size: 1 byte Arguments: Arg0 = register index A = Regs[Arg0]; Regs[Arg0] = A << 1 | S.carry & 0x01; S.carry = A & 0x80; Instruction Byte 0 ROL R 0x0F \\| Arg0 << 5 ADD R, R (Add Register to Register) Adds the values of two registers and stores it in the first. Size: 2 bytes Arguments: Arg0 = register index Arg1 = register index A = Regs[Arg0]; B = Regs[Arg1]; S.carry = (A + B) > 0xFF; S.negative = 0; S.zero = (A + B) == 0; Regs[Arg0] = A + B; Instruction Byte 0 Byte 1 ADD R, R 0x10 \\| (Arg0 << 5) Arg1 XNOR R, R (XNOR Registers) Performs a bitwise XNOR operation on two registers and stores it in the first. Size: 2 bytes Arguments: Arg0 = register index Arg1 = register index A = Regs[Arg0]; B = Regs[Arg1]; Regs[Arg0] = ~(A ^ B); Instruction Byte 0 Byte 1 XNOR R, R 0x11 \\| (Arg0 << 5) Arg1 SUB R, R (Subtract Register from Register) Subtracts the value of one register from another and stores it in the first. Size: 2 bytes Arguments: Arg0 = register index Arg1 = register index A = Regs[Arg0]; B = Regs[Arg1]; S.carry = (A + ~B + 1) > 0xFF; S.negative = (A - B) < 0; S.zero = (A - B) == 0; Regs[Arg0] = (A + ~B + 1); Instruction Byte 0 Byte 1 SUB R, R 0x12 \\| (Arg0 << 5) Arg1 XOR R, R (XOR Registers) Performs a bitwise XOR operation on two registers and stores it in the first. Size: 2 bytes Arguments: Arg0 = register index Arg1 = register index A = Regs[Arg0]; B = Regs[Arg1]; Regs[Arg0] = A ^ B; Instruction Byte 0 Byte 1 XOR R, R 0x13 \\| (Arg0 << 5) Arg1 OR R, R (OR Registers) Performs a bitwise OR operation on two registers and stores it in the first. Size: 2 bytes Arguments: Arg0 = register index Arg1 = register index A = Regs[Arg0]; B = Regs[Arg1]; Regs[Arg0] = A | B; Instruction Byte 0 Byte 1 OR R, R 0x14 \\| (Arg0 << 5) Arg1 NOR R, R (NOR Registers) Performs a bitwise NOR operation on two registers and stores it in the first. Size: 2 bytes Arguments: Arg0 = register index Arg1 = register index A = Regs[Arg0]; B = Regs[Arg1]; Regs[Arg0] = ~(A | B); Instruction Byte 0 Byte 1 NOR R, R 0x15 \\| (Arg0 << 5) Arg1 NAND R, R (NAND Registers) Performs a bitwise NAND operation on two registers and stores it in the first. Size: 2 bytes Arguments: Arg0 = register index Arg1 = register index A = Regs[Arg0]; B = Regs[Arg1]; Regs[Arg0] = ~(A & B); Instruction Byte 0 Byte 1 NAND R, R 0x16 \\| (Arg0 << 5) Arg1 AND R, R (AND Registers) Performs a bitwise AND operation on two registers and stores it in the first. Size: 2 bytes Arguments: Arg0 = register index Arg1 = register index A = Regs[Arg0]; B = Regs[Arg1]; Regs[Arg0] = A & B; Instruction Byte 0 Byte 1 AND R, R 0x17 \\| (Arg0 << 5) Arg1 ADC R, R (Add with Carry) Adds a register to another with a carry bit. Size: 2 bytes Arguments: Arg0 = register index Arg1 = register index A = Regs[Arg0]; B = Regs[Arg1]; S.negative = 0; S.zero = (A + B + S.carry) == 0; Regs[Arg0] = A + B + S.carry; S.carry = (A + B + S.carry) > 0xFF; Instruction Byte 0 Byte 1 ADC R, R 0x18 \\| (Arg0 << 5) Arg1 PHR R (Push Register) Pushes the value of a register onto the stack. Size: 1 byte Arguments: Arg0 = register index Memory[SP + 0x100] = Regs[Arg0]; SP--; Instruction Byte 0 PHR R 0x19 \\| Arg0 << 5 SBC R, R (Subtract with Carry) Subtracts one register from another with a carry bit. Size: 2 bytes Arguments: Arg0 = register index Arg1 = register index A = Regs[Arg0]; B = Regs[Arg1]; S.zero = (A + ~B + S.carry) == 0; Regs[Arg0] = (A + ~B + S.carry); S.carry = (A + ~B + S.carry) > 0xFF; S.negative = !S.carry && !S.zero; Instruction Byte 0 Byte 1 SBC R, R 0x1A \\| (Arg0 << 5) Arg1 PLR R (Pull Register) Pulls a value from the stack into a register. Size: 1 byte Arguments: Arg0 = register index SP--; Regs[Arg0] = Memory[SP + 0x100]; Instruction Byte 0 PHR R 0x1B \\| Arg0 << 5 JSR A (Jump to Subroutine) Jumps to a subroutine and saves the return address to stack. Size: 3 bytes Arguments: Arg0 = subroutine address Memory[SP + 0x100] = (PC & 0xFF00) >> 8; SP--; Memory[SP + 0x100] = PC & 0xFF; SP--; PC = Arg0; Instruction Byte 0 Byte 1-2 JSR A 0x1C Arg0 in LE format CMP R,R (Compare Registers) Compares the values of two registers. Size: 2 bytes Arguments: Arg0 = register index Arg1 = register index A = Regs[Arg0]; B = Regs[Arg1]; S.carry = (A + ~B + 1) > 0xFF; S.negative = (A - B) < 0; S.zero = (A - B) == 0; Instruction Byte 0 Byte 1 CMP R, R 0x1D \\| (Arg0 << 5) Arg1 DEC R (Decrement Register) Decrements the value of a register by one. Size: 1 byte Arguments: Arg0 = register index Regs[Arg0] -= 1; Instruction Byte 0 DEC R 0x1E \\| Arg0 << 5 INC R (Increment Register) Increments the value of a register by one. Size: 1 byte Arguments: Arg0 = register index Regs[Arg0] += 1; Instruction Byte 0 INC R 0x1F \\| Arg0 << 5 JMP A (Jump to Address) Jumps to a specified memory address. Size: 3 bytes Arguments: Arg0 = subroutine address PC = Arg0; Instruction Byte 0 Byte 1-2 JMP A 0x20 Arg0 in LE format CLC (Clear Carry) Clears the carry flag. Size: 1 byte S.carry = 0; Instruction Byte 0 CLC 0x23 STC (Set Carry) Sets the carry flag. Size: 1 byte S.carry = 1; Instruction Byte 0 STC 0x26 HLT (Halt) Halts the processor. Size: 1 byte Instruction Byte 0 HLT 0x2B RTS (Return from Subroutine) Returns from a subroutine to the calling address. Size: 1 byte PC = Memory[SP + 0x100 + 1] | (Memory[SP + 0x100 + 2] << 8); SP += 2; Instruction Byte 0 RTS 0x3C","title":"Instruction set"},{"location":"instruction-set/#instruction-set","text":"","title":"Instruction set"},{"location":"instruction-set/#arguments","text":"Argument Type Meaning R Register index [A, X, Y, SP, R0, R1, R2, R3] A Addressing mode (0-15) flags Condition Flags","title":"Arguments"},{"location":"instruction-set/#instruction-list","text":"Mnemonic binary Mnemonic binary RST 00000000 JMP A 00100000 MOV R,R 00000001 reserved 00100001 MOV R,A 00000010 reserved 00100010 MOV A,A 00000011 CLC 00100011 MOV A,R 00000100 reserved 00100100 BRH flags, A 00000101 reserved 00100101 DEX 00000110 STC 00100110 illegal 00000111 illegal 00100111 ADD R, A 00001000 reserved 00101000 SUB R, A 00001001 reserved 00101001 INX 00001010 illegal 00101010 NOP 00001011 HLT 00101011 RSH R 00001100 reserved 00101100 LSH R 00001101 reserved 00101101 ROR R 00001110 reserved 00101110 ROL R 00001111 reserved 00101111 ADD R, R 00010000 reserved 00110000 XNOR R, R 00010001 reserved 00110001 SUB R, R 00010010 reserved 00110010 XOR R, R 00010011 reserved 00110011 OR R, R 00010100 reserved 00110100 NOR R, R 00010101 reserved 00110101 NAND R, R 00010110 reserved 00110110 AND R, R 00010111 reserved 00110111 ADC R, R 00011000 reserved 00111000 PHR R 00011001 reserved 00111001 SBC R, R 00011010 reserved 00111010 PLR R 00011011 reserved 00111011 JSR 00011100 RTS 00111100 CMP R,R 00011101 reserved 00111101 DEC R 00011110 reserved 00111110 INC R 00011111 reserved 00111111","title":"Instruction List"},{"location":"instruction-set/#instruction-descriptions","text":"Each instruction in the instruction set is documented with the following structure: Instruction Name and Description : The name of the instruction is provided as a heading, followed by a brief description of its purpose and functionality. Arguments : If the instruction takes arguments, they are listed and described. For example, the source and destination registers or memory addresses. C Representation : A snippet of C code is provided to represent the behavior of the instruction. This helps in understanding how the instruction operates at a low level. Memory is a 64kB array (65536 bytes), represents the full memory region (0x0000-0xFFFF). The registers are represented with their name: PC , ACC , X , Y , SP , R0 , R1 , R2 , R3 . The resolveAddress function represents the addresssing mode logic, see Addressing modes , A and B are the ALU's internal registers. Instruction Encoding : The encoding of the instruction in memory is detailed in a table. This includes the byte values and how arguments are encoded into the instruction. Each addressing mode has a differt size in bytes after the instruction, so byte numbers in the instruction descriptions may not be correct.","title":"Instruction descriptions"},{"location":"instruction-set/#rst-reset","text":"Resets the processor to its initial state. Before executing this instruction the X register must be set to zero. Size: 1 byte PC = Memory[(X - 1) << 8 + (X - 2)] << 8 + Memory[(X - 1) << 8 + (X - 1)]; X -= 1; So if X is 0 PC will be set to the reset vector at 0xFFFE - 0xFFFF Instruction Byte 0 RST 0x00","title":"RST (Reset)"},{"location":"instruction-set/#mov-rr-move-register-to-register","text":"Transfers data from one register to another. Size: 2 bytes Arguments: Arg0 = Destinarion register index Arg1 = Source register index Regs[Arg0] = Regs[Arg1]; Instruction Byte 0 Byte 1 MOV R, R 0x01 \\| (Arg0 << 5) Arg1","title":"MOV R,R (Move Register to Register)"},{"location":"instruction-set/#mov-ra-move-register-to-address","text":"Moves data from a register to a specified memory address. Size: 2-4 bytes depending on the addressing mode Arguments: Arg0 = Destinarion register index Arg1 = Addressing mode for source byte Regs[Arg0] = *resolveAddress(Arg1); Instruction Byte 0 Byte 1 Byte 2... MOV R, A 0x02 \\| (Arg0 << 5) Arg1 Arguments for addressing mode","title":"MOV R,A (Move Register to Address)"},{"location":"instruction-set/#mov-aa-move-address-to-address","text":"Transfers data between two memory addresses. Size: 2-6 bytes depending on the addressing modes Arguments: Arg0 = Addressing mode for destination Arg1 = Addressing mode for source byte *resolveAddress(Arg0) = *resolveAddress(Arg1); Instruction Byte 0 Byte 1 Byte 2... MOV R, A 0x03 Arg1 \\| Arg0 << 5 Arguments for addressing modes ( Arg0 first)","title":"MOV A,A (Move Address to Address)"},{"location":"instruction-set/#mov-ar-move-address-to-register","text":"Moves data from a memory address to a register. Size: 2-4 bytes depending on the addressing mode Arguments: Arg0 = Addressing mode for destination Arg1 = Source register index *resolveAddress(Arg0) = Regs[Arg1]; Instruction Byte 0 Byte 1 Byte 2... MOV R, A 0x04 \\| (Arg1 << 5) Arg0 Arguments for addressing mode","title":"MOV A,R (Move Address to Register)"},{"location":"instruction-set/#brh-flags-a-branch-on-flags","text":"Branches to a specified address based on condition flags. Only 1 flag should be set, if more are set it work as an or operation (if eighter is true it will branch) Size: 3 bytes Arguments: Arg0 = conditon flags, compared with the Status register = Carry | Zero << 1 | Negative << 2 Arg1 = An absolute address, where it will jump to if the conditions are true. (2 bytes) if (S & Arg0) { PC = Arg1; } Instruction Byte 0 Byte 1-2 BRH flags, A 0x05 \\| (Arg0 << 5) Arg1 in LE format","title":"BRH flags, A (Branch on Flags)"},{"location":"instruction-set/#dex-decrement-x","text":"Decrements the X index register by one. Size: 1 byte X -= 1; Instruction Byte 0 DEX 0x06","title":"DEX (Decrement X)"},{"location":"instruction-set/#add-r-a-add-register-and-address","text":"Adds the value at a memory address to a register. Size: 2-4 bytes depending on the addressing mode Arguments: Arg0 = register index Arg1 = Addressing mode A = Regs[Arg0]; B = *resolveAddress(Arg1); S.carry = (A + B) > 0xFF; S.negative = 0; S.zero = (A + B) == 0; Regs[Arg0] = A + B; Instruction Byte 0 Byte 1 Byte 2... ADD R, A 0x08 \\| (Arg0 << 5) Arg1 Arguments for addressing mode","title":"ADD R, A (Add Register and Address)"},{"location":"instruction-set/#sub-r-a-subtract-address-from-register","text":"Subtracts the value at a memory address from a register. Size: 2-4 bytes depending on the addressing mode Arguments: Arg0 = register index Arg1 = Addressing mode A = Regs[Arg0]; B = *resolveAddress(Arg1); S.carry = (A + ~B + 1) > 0xFF; S.negative = (A - B) < 0; S.zero = (A - B) == 0; Regs[Arg0] = (A + ~B + 1); Instruction Byte 0 Byte 1 Byte 2... SUB R, A 0x09 \\| (Arg0 << 5) Arg1 Arguments for addressing mode","title":"SUB R, A (Subtract Address from Register)"},{"location":"instruction-set/#inx-increment-x","text":"Increments the X register by one. Size: 1 byte X += 1; Instruction Byte 0 INX 0x0A","title":"INX (Increment X)"},{"location":"instruction-set/#nop-no-operation","text":"Performs no operation and advances to the next instruction. Size: 1 byte Instruction Byte 0 NOP 0x0B","title":"NOP (No Operation)"},{"location":"instruction-set/#rsh-r-right-shift-register","text":"Shifts the bits in a register to the right. Size: 1 byte Arguments: Arg0 = register index A = Regs[Arg0]; S.carry = (bool)(A & 0x01); Regs[Arg0] = A >> 1; Instruction Byte 0 RSH R 0x0C \\| Arg0 << 5","title":"RSH R (Right Shift Register)"},{"location":"instruction-set/#lsh-r-left-shift-register","text":"Shifts the bits in a register to the left. Size: 1 byte Arguments: Arg0 = register index A = Regs[Arg0]; S.carry = (bool)(A & 0x80); Regs[Arg0] = A << 1; Instruction Byte 0 LSH R 0x0D \\| Arg0 << 5","title":"LSH R (Left Shift Register)"},{"location":"instruction-set/#ror-r-rotate-right-register","text":"Rotates the bits in a register to the right, including the carry bit. Size: 1 byte Arguments: Arg0 = register index A = Regs[Arg0]; Regs[Arg0] = A >> 1 | S.carry << 7; S.carry = A & 0x01; Instruction Byte 0 ROR R 0x0E \\| Arg0 << 5","title":"ROR R (Rotate Right Register)"},{"location":"instruction-set/#rol-r-rotate-left-register","text":"Rotates the bits in a register to the left. Size: 1 byte Arguments: Arg0 = register index A = Regs[Arg0]; Regs[Arg0] = A << 1 | S.carry & 0x01; S.carry = A & 0x80; Instruction Byte 0 ROL R 0x0F \\| Arg0 << 5","title":"ROL R (Rotate Left Register)"},{"location":"instruction-set/#add-r-r-add-register-to-register","text":"Adds the values of two registers and stores it in the first. Size: 2 bytes Arguments: Arg0 = register index Arg1 = register index A = Regs[Arg0]; B = Regs[Arg1]; S.carry = (A + B) > 0xFF; S.negative = 0; S.zero = (A + B) == 0; Regs[Arg0] = A + B; Instruction Byte 0 Byte 1 ADD R, R 0x10 \\| (Arg0 << 5) Arg1","title":"ADD R, R (Add Register to Register)"},{"location":"instruction-set/#xnor-r-r-xnor-registers","text":"Performs a bitwise XNOR operation on two registers and stores it in the first. Size: 2 bytes Arguments: Arg0 = register index Arg1 = register index A = Regs[Arg0]; B = Regs[Arg1]; Regs[Arg0] = ~(A ^ B); Instruction Byte 0 Byte 1 XNOR R, R 0x11 \\| (Arg0 << 5) Arg1","title":"XNOR R, R (XNOR Registers)"},{"location":"instruction-set/#sub-r-r-subtract-register-from-register","text":"Subtracts the value of one register from another and stores it in the first. Size: 2 bytes Arguments: Arg0 = register index Arg1 = register index A = Regs[Arg0]; B = Regs[Arg1]; S.carry = (A + ~B + 1) > 0xFF; S.negative = (A - B) < 0; S.zero = (A - B) == 0; Regs[Arg0] = (A + ~B + 1); Instruction Byte 0 Byte 1 SUB R, R 0x12 \\| (Arg0 << 5) Arg1","title":"SUB R, R (Subtract Register from Register)"},{"location":"instruction-set/#xor-r-r-xor-registers","text":"Performs a bitwise XOR operation on two registers and stores it in the first. Size: 2 bytes Arguments: Arg0 = register index Arg1 = register index A = Regs[Arg0]; B = Regs[Arg1]; Regs[Arg0] = A ^ B; Instruction Byte 0 Byte 1 XOR R, R 0x13 \\| (Arg0 << 5) Arg1","title":"XOR R, R (XOR Registers)"},{"location":"instruction-set/#or-r-r-or-registers","text":"Performs a bitwise OR operation on two registers and stores it in the first. Size: 2 bytes Arguments: Arg0 = register index Arg1 = register index A = Regs[Arg0]; B = Regs[Arg1]; Regs[Arg0] = A | B; Instruction Byte 0 Byte 1 OR R, R 0x14 \\| (Arg0 << 5) Arg1","title":"OR R, R (OR Registers)"},{"location":"instruction-set/#nor-r-r-nor-registers","text":"Performs a bitwise NOR operation on two registers and stores it in the first. Size: 2 bytes Arguments: Arg0 = register index Arg1 = register index A = Regs[Arg0]; B = Regs[Arg1]; Regs[Arg0] = ~(A | B); Instruction Byte 0 Byte 1 NOR R, R 0x15 \\| (Arg0 << 5) Arg1","title":"NOR R, R (NOR Registers)"},{"location":"instruction-set/#nand-r-r-nand-registers","text":"Performs a bitwise NAND operation on two registers and stores it in the first. Size: 2 bytes Arguments: Arg0 = register index Arg1 = register index A = Regs[Arg0]; B = Regs[Arg1]; Regs[Arg0] = ~(A & B); Instruction Byte 0 Byte 1 NAND R, R 0x16 \\| (Arg0 << 5) Arg1","title":"NAND R, R (NAND Registers)"},{"location":"instruction-set/#and-r-r-and-registers","text":"Performs a bitwise AND operation on two registers and stores it in the first. Size: 2 bytes Arguments: Arg0 = register index Arg1 = register index A = Regs[Arg0]; B = Regs[Arg1]; Regs[Arg0] = A & B; Instruction Byte 0 Byte 1 AND R, R 0x17 \\| (Arg0 << 5) Arg1","title":"AND R, R (AND Registers)"},{"location":"instruction-set/#adc-r-r-add-with-carry","text":"Adds a register to another with a carry bit. Size: 2 bytes Arguments: Arg0 = register index Arg1 = register index A = Regs[Arg0]; B = Regs[Arg1]; S.negative = 0; S.zero = (A + B + S.carry) == 0; Regs[Arg0] = A + B + S.carry; S.carry = (A + B + S.carry) > 0xFF; Instruction Byte 0 Byte 1 ADC R, R 0x18 \\| (Arg0 << 5) Arg1","title":"ADC R, R (Add with Carry)"},{"location":"instruction-set/#phr-r-push-register","text":"Pushes the value of a register onto the stack. Size: 1 byte Arguments: Arg0 = register index Memory[SP + 0x100] = Regs[Arg0]; SP--; Instruction Byte 0 PHR R 0x19 \\| Arg0 << 5","title":"PHR R (Push Register)"},{"location":"instruction-set/#sbc-r-r-subtract-with-carry","text":"Subtracts one register from another with a carry bit. Size: 2 bytes Arguments: Arg0 = register index Arg1 = register index A = Regs[Arg0]; B = Regs[Arg1]; S.zero = (A + ~B + S.carry) == 0; Regs[Arg0] = (A + ~B + S.carry); S.carry = (A + ~B + S.carry) > 0xFF; S.negative = !S.carry && !S.zero; Instruction Byte 0 Byte 1 SBC R, R 0x1A \\| (Arg0 << 5) Arg1","title":"SBC R, R (Subtract with Carry)"},{"location":"instruction-set/#plr-r-pull-register","text":"Pulls a value from the stack into a register. Size: 1 byte Arguments: Arg0 = register index SP--; Regs[Arg0] = Memory[SP + 0x100]; Instruction Byte 0 PHR R 0x1B \\| Arg0 << 5","title":"PLR R (Pull Register)"},{"location":"instruction-set/#jsr-a-jump-to-subroutine","text":"Jumps to a subroutine and saves the return address to stack. Size: 3 bytes Arguments: Arg0 = subroutine address Memory[SP + 0x100] = (PC & 0xFF00) >> 8; SP--; Memory[SP + 0x100] = PC & 0xFF; SP--; PC = Arg0; Instruction Byte 0 Byte 1-2 JSR A 0x1C Arg0 in LE format","title":"JSR A (Jump to Subroutine)"},{"location":"instruction-set/#cmp-rr-compare-registers","text":"Compares the values of two registers. Size: 2 bytes Arguments: Arg0 = register index Arg1 = register index A = Regs[Arg0]; B = Regs[Arg1]; S.carry = (A + ~B + 1) > 0xFF; S.negative = (A - B) < 0; S.zero = (A - B) == 0; Instruction Byte 0 Byte 1 CMP R, R 0x1D \\| (Arg0 << 5) Arg1","title":"CMP R,R (Compare Registers)"},{"location":"instruction-set/#dec-r-decrement-register","text":"Decrements the value of a register by one. Size: 1 byte Arguments: Arg0 = register index Regs[Arg0] -= 1; Instruction Byte 0 DEC R 0x1E \\| Arg0 << 5","title":"DEC R (Decrement Register)"},{"location":"instruction-set/#inc-r-increment-register","text":"Increments the value of a register by one. Size: 1 byte Arguments: Arg0 = register index Regs[Arg0] += 1; Instruction Byte 0 INC R 0x1F \\| Arg0 << 5","title":"INC R (Increment Register)"},{"location":"instruction-set/#jmp-a-jump-to-address","text":"Jumps to a specified memory address. Size: 3 bytes Arguments: Arg0 = subroutine address PC = Arg0; Instruction Byte 0 Byte 1-2 JMP A 0x20 Arg0 in LE format","title":"JMP A (Jump to Address)"},{"location":"instruction-set/#clc-clear-carry","text":"Clears the carry flag. Size: 1 byte S.carry = 0; Instruction Byte 0 CLC 0x23","title":"CLC (Clear Carry)"},{"location":"instruction-set/#stc-set-carry","text":"Sets the carry flag. Size: 1 byte S.carry = 1; Instruction Byte 0 STC 0x26","title":"STC (Set Carry)"},{"location":"instruction-set/#hlt-halt","text":"Halts the processor. Size: 1 byte Instruction Byte 0 HLT 0x2B","title":"HLT (Halt)"},{"location":"instruction-set/#rts-return-from-subroutine","text":"Returns from a subroutine to the calling address. Size: 1 byte PC = Memory[SP + 0x100 + 1] | (Memory[SP + 0x100 + 2] << 8); SP += 2; Instruction Byte 0 RTS 0x3C","title":"RTS (Return from Subroutine)"}]}